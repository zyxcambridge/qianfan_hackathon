import { MessageFile, MessageFileType } from '../../../types/messageFile';
import { ServiceIO } from '../../../services/serviceIO';
import { MessageContentI } from '../../../types/messagesInternal';
import { ResponseI } from '../../../types/responseInternal';
import { HTMLClassUtilities } from '../../../types/html';
import { DemoResponse } from '../../../types/demo';
import { DeepChat } from '../../../deepChat';
import { ErrorMessageOverrides, MessageElementsStyles, MessageRoleStyles, MessageStyles } from '../../../types/messages';
export interface MessageElements {
    outerContainer: HTMLElement;
    innerContainer: HTMLElement;
    bubbleElement: HTMLElement;
}
export declare class Messages {
    elementRef: HTMLElement;
    readonly messageStyles?: MessageStyles;
    private _messageElementRefs;
    private readonly _avatars?;
    private readonly _names?;
    private readonly _errorMessageOverrides?;
    private readonly _onNewMessage?;
    private readonly _onClearMessages?;
    private readonly _displayLoadingMessage?;
    private readonly _permittedErrorPrefixes?;
    private readonly _displayServiceErrorMessages?;
    private readonly _textElementsToText;
    private _remarkable;
    private _textToSpeech?;
    private _introPanel?;
    private _introMessage?;
    private _streamedText;
    readonly htmlClassUtilities: HTMLClassUtilities;
    messages: MessageContentI[];
    customDemoResponse?: DemoResponse;
    submitUserMessage?: (text: string) => void;
    constructor(deepChat: DeepChat, serviceIO: ServiceIO, panel?: HTMLElement);
    private static getDisplayLoadingMessage;
    private prepareDemo;
    private static createContainerElement;
    private addSetupMessageIfNeeded;
    private addIntroductoryMessage;
    private populateInitialMessages;
    applyCustomStyles(elements: MessageElements | undefined, role: string, media: boolean, otherStyles?: MessageRoleStyles | MessageElementsStyles): void;
    private addInnerContainerElements;
    private static processMessageContent;
    private static createBaseElements;
    private createMessageElements;
    private static isTemporaryElement;
    createNewMessageElement(text: string, role: string): MessageElements;
    private createAndAppendNewMessageElement;
    static editEmptyMessageElement(bubbleElement: HTMLElement): void;
    private addNewTextMessage;
    addNewMessage(data: ResponseI, isInitial?: boolean): void;
    private updateStateOnMessage;
    private sendClientUpdate;
    private removeMessageOnError;
    addNewErrorMessage(type: keyof Omit<ErrorMessageOverrides, 'default'>, message?: string): void;
    private static checkPermittedErrorPrefixes;
    private getPermittedMessage;
    private getLastMessageElement;
    private getLastMessageBubbleElement;
    isLastMessageError(): boolean | undefined;
    removeError(): void;
    addLoadingMessage(): void;
    addNewStreamedMessage(role?: string): void;
    updateStreamedMessage(text: string, isIncrement?: boolean): void;
    isStreamingText(): boolean;
    finaliseStreamedMessage(): void;
    private populateIntroPanel;
    addMultipleFiles(filesData: {
        file: File;
        type: MessageFileType;
    }[]): Promise<MessageFile[]>;
    private clearMessages;
    private scrollToBottom;
    private refreshTextMessages;
}
//# sourceMappingURL=messages.d.ts.map